---
title: Java之内部类
date: 2019-03-11 16:19:29
tags: Java
categories: Java
---

### 为什么需要内部类？

首先举一个简单的例子，如果你想实现一个接口，但是这个接口中的一个方法和你构想的这个类中的一个方法的名称，参数相同，你应该怎么办？这时候，你可以创建一个内部类实现这个接口。由于内部类对于外部类的所有内容都是可以访问的，所以这样做可以完成你直接实现这个接口的功能。

不过你可能要质疑，更改一下方法不就可以了吗？

的确，以此作为设计内部类的理由，没有说服力。

真正的原因是这样的，java中的内部类和接口加在一起，可以解决常被C++程序员抱怨java中存在的一个问题 没有多继承。实际上，c++的多继承设计起来很复杂，而java通过内部类+接口，可以很好的实现多继承的效果。

### 内部类分类
* 成员内部类：外部类的成员。
* 局部内部类：定义在一个方法里面甚至一个代码块之内
* 静态内部类：类似于静态成员。
* 匿名内部类：实现一个接口 or 继承一个抽象类。


### 内部类作用

* 更好的封装性，隐藏你不想让别人知道的操作
* 内部类成员可以直接访问外部类的私有数据，因为内部类被当成其外部类成员，但外部类不能访问内部类的实现细节，例如内部类的成员变量
* 匿名内部类适合用于创建那些仅需要一次使用的类


### Demo:通过内部类来实例化pojo对象
<https://blog.csdn.net/cd18333612683/article/details/79129503>

### 局部内部类
```java
复制代码
public class TestInnerClass{
    public static void main(String args[]){
        Goods good = new Goods();
        
        Destination destination = good.dest("beijing");
        System.out.println(destination.readLabel());
    }
}

interface Destination{
    String readLabel();
}
class Goods{
    public Destination dest(String s){
        class GDestination implements Destination{
            private String label;
            public GDestination(String whereTo){
                label = whereTo;
            }
            public String readLabel(){
                return label;
            }
        }
        return new GDestination(s);
    }
}
```
上面就是这样一个例子。在方法dest（）中我们定义了一个内部类，最后由这个方法返回这个内部类。如果我们在创建一个对象的时候仅需要创建一个对象并且创给外部，就可以这样做。当然，定义在方法中的内部类可以使设计多样化，用途绝不仅仅在这一点。

### 静态内部类
#### 静态内部类的使用目的。 

在定义内部类的时候，可以在其前面加上一个权限修饰符static。此时这个内部类就变为了静态内部类。不过由于种种的原因，如使用上的限制等等因素(具体的使用限制，笔者在下面的内容中会详细阐述)，在实际工作中用的并不是很多。但是并不是说其没有价值。在某些特殊的情况下，少了这个静态内部类还真是不行。如在进行代码程序测试的时候，如果在每一个Java源文件中都设置一个主方法(主方法是某个应用程序的入口，必须具有)，那么会出现很多额外的代码。而且最主要的时这段主程序的代码对于Java文件来说，只是一个形式，其本身并不需要这种主方法。但是少了这个主方法又是万万不行的。在这种情况下，就可以将主方法写入到静态内部类中，从而不用为每个Java源文件都设置一个类似的主方法。这对于代码测试是非常有用的。在一些中大型的应用程序开发中，则是一个常用的技术手段。为此，这个静态内部类虽然不怎么常用，但是程序开发人员还必须要掌握它。也许在某个关键的时刻，其还可以发挥巨大的作用也说不定。 

#### 静态内部类的使用限制。 

* 静态成员(包括静态变量与静态成员)的定义。
一般情况下，如果一个内部类不是被定义成静态内部类，那么在定义成员变量或者成员方法的时候，是不能够被定义成静态成员变量与静态成员方法的。也就是说，在非静态内部类中不可以声明静态成员。如现在在一个student类中定义了一个内部类age，如果没有将这个类利用static关键字修饰，即没有定义为静态类，那么在这个内部类中如果要利用static关键字来修饰某个成员方法或者成员变量是不允许的。在编译的时候就通不过。故程序开发人员需要注意，只有将某个内部类修饰为静态类，然后才能够在这个类中定义静态的成员变量与成员方法。这是静态内部类都有的一个特性。也正是因为这个原因，有时候少了这个静态的内部类，很多工作就无法完成。或者说要绕一个大圈才能够实现某个用户的需求。这也是静态的内部类之所以要存在的一个重要原因。 

* 在成员的引用上，有比较大的限制。
一般的非静态内部类，可以随意的访问外部类中的成员变量与成员方法。即使这些成员方法被修饰为private(私有的成员变量或者方法)，其非静态内部类都可以随意的访问。则是非静态内部类的特权。因为在其他类中是无法访问被定义为私有的成员变量或则方法。但是如果一个内部类被定义为静态的，那么在银用外部类的成员方法或则成员变量的时候，就会有诸多的限制。如不能够从静态内部类的对象中访问外部类的非静态成员(包括成员变量与成员方法)。这是什么意思呢?如果在外部类中定义了两个变量，一个是非静态的变量，一个是静态的变量。那么在静态内部类中，无论在成员方法内部还是在其他地方，都只能够引用外部类中的静态的变量，而不能够访问非静态的变量。在静态内部类中，可以定义静态的方法(也只有在静态的内部类中可以定义静态的方法)，在静态方法中引用外部类的成员。但是无论在内部类的什么地方引用，有一个共同点，即都只能够引用外部类中的静态成员方法或者成员变量。对于那些非静态的成员变量与成员方法，在静态内部类中是无法访问的。这就是静态内部类的最大使用限制。在普通的非静态内部类中是没有这个限制的。也正是这个原因，决定了静态内部类只应用在一些特定的场合。其应用范围远远没有像非静态的内部类那样广泛。 

* 在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。 

通常情况下，在一个类中创建成员内部类的时候，有一个强制性的规定，即内部类的实例一定要绑定在外部类的实例中。也就是说，在创建内部类之前要先在外部类中要利用new关键字来创建这个内部类的对象。如此的话如果从外部类中初始化一个内部类对象，那么内部类对象就会绑定在外部类对象上。也就是说，普通非静态内部类的对象是依附在外部类对象之中的。但是，如果成员开发人员创建的时静态内部类，那么这就又另当别论了。通常情况下，程序员在定义静态内部类的时候，是不需要定义绑定在外部类的实例上的。也就是说，要在一个外部类中定义一个静态的内部类，不需要利用关键字new来创建内部类的实例。即在创建静态类内部对象时，不需要其外部类的对象。具体为什么会这样，一般程序开发人员不需要了解这么深入，只需要记住有这个规则即可。在定义静态内部类的时候，千万不要犯画蛇添足的错误。 

　　
从以上的分析中可以看出，静态内部类与非静态的内部类还是有很大的不同的。一般程序开发人员可以这么理解，非晶态的内部类对象隐式地在外部类中保存了一个引用，指向创建它的外部类对象。不管怎么理解，程序开发人员都需要牢记静态内部类与非静态内部类的差异。如是否可以创建静态的成员方法与成员变量(静态内部类可以创建静态的成员而非静态的内部类不可以)、对于访问外部类的成员的限制(静态内部类只可以访问外部类中的静态成员变量与成员方法而非静态的内部类即可以访问静态的也可以访问非静态的外部类成员方法与成员变量)。这两个差异是静态内部类与非静态外部类最大的差异，也是静态内部类之所以存在的原因。了解了这个差异之后，程序开发人员还需要知道，在什么情况下该使用静态内部类。如在程序测试的时候，为了避免在各个Java源文件中书写主方法的代码，可以将主方法写入到静态内部类中，以减少代码的书写量，让代码更加的简洁。 


### 参考
<https://www.cnblogs.com/gaodong/p/3608665.html>
<https://www.cnblogs.com/Gaojiecai/p/4041663.html>
