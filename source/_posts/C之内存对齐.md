---
title: C之内存对齐
date: 2018-04-06 09:48:08
tags: C
categories: C
---
#  内存对齐

```c

#include<stdio.h>

typedef struct bb
{
	int id;     //[0]-[3] 第一个数据成员放在offset为0的地方 
	double weight;//从该成员的大小的整数倍位置开始存，也就是[8]-[15] 
	float height; //[16]-[19],结构体的总大小必须是内部最大成员的整数倍，不足的补齐，所以补上[20]-[23] 
}BB;

typedef struct aa
{
	char name[2]; //[0]-[1]
	int id;   //[4]-[7]
	
	double score;  //[8]-[15]
	short grade;   // [16]-[17]  从该成员的大小的整数倍开始存，也就是24 
	BB b;  //[24]-[47]
	}AA;

int main()
{
	AA a;
	BB b;
	printf("%d\n",sizeof(a));
	printf("%d",sizeof(b));
	
	return 0;
}
// #pragma pack(1)    不内存对齐  32 16 
// #pragma pack(2)   32 16
// #pragma pack(4)  36 16
// #pragma pack(8)  48 24 
```

* 如果#pragma pack (n)中指定的n大于结构体中最大成员的size，则其不起作用，结构体仍然按照size最大的成员进行对界。
* **为什么要进行内存对齐？**
1. 一种提高内存访问速度的策略，cpu在访问未对其的内存需要经过两次内存访问，而经过内存对齐一次就可以了。
2. 平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常

* 其实数据在内存中存放时，是否对齐并不重要，重要的是你怎样去访问它。memcpy的实现本身并不简单(你在源码里看到的通过while每次拷贝一个char的只是一个例子，并不是真实的memcpy)，它考虑了是否对齐。当检测到内存是对齐时，memcpy调用合适的指令(比较这里拷贝一个int，就调用LDR)，一次拷贝多个字节，以提高效率。当检测到不对齐时，先调用LDRB遂个字节拷贝，直到对齐部分后再调用合适的指令拷贝。因此，在上面的例子中，它是先调用LDRB的，因为LDRB是按1byte对齐(所有的内存都按这个对齐)，所以不会触发报错。但效率就要慢一点了，毕竟要拷贝几次。内存对齐本身对程序员来说是透明的，即程序员该取变量就取变量，该存就存，编译程序时编译器会把变量按本身的平台进行对齐。况且现在的CPU都很高级，别说服务器，台式机的CPU，ARM 7以上应该也支持内存不对齐访问了。但如果你要写一个内存池(boost的ordered_pool有对齐的例子)，或者使用了reinterpret_cast这种对内存直接进行操作的函数，这方面还是要注意一下，即使CPU支持，效率也会受到影响。
*  #pragma pack(push,1) #pragma pack(pop)强制把结构体按照1byte对齐。
